// Show/hide sections
function showSection(sectionId) {
    document.querySelectorAll('.section').forEach(section => {
      section.style.display = 'none';
    });
    document.getElementById(sectionId).style.display = 'block';
}

// Bot testing functionality
async function testBot() {
    const token = document.getElementById('bot-token').value;
    const command = document.getElementById('test-command').value;
    
    if (!token || !command) {
        alert('Please enter both token and command');
        return;
    }

try {
     const Discord = require('discord.js');
        const client = new Discord.Client({
         intents: [
        Discord.GatewayIntentBits.Guilds,
       Discord.GatewayIntentBits.GuildMessages
    ]
        });

        await client.login(token);
        console.log('Bot logged in successfully!');
     
        // Add event listeners for basic functionality
  client.on('ready', () => {
     alert(`Bot logged in as ${client.user.tag}`);
  });

        client.on('messageCreate', message => {
     if (message.content === command) {
  message.reply('Command received and working!');
            }
 });
    } catch (error) {
        alert('Error testing bot: ' + error.message);
    }
}

// Webhook manager functionality with enhanced features
async function sendWebhook() {
    const webhookUrl = document.getElementById('webhook-url').value;
 const message = document.getElementById('webhook-message').value;
    const embedColor = document.getElementById('embed-color').value;
  const embedTitle = document.getElementById('embed-title').value;

    try {
        const payload = {
  content: message,
            embeds: []
        };

        if (embedTitle) {
            payload.embeds.push({
       title: embedTitle,
                color: parseInt(embedColor.replace('#', ''), 16),
   timestamp: new Date().toISOString()
            });
   }

        const response = await fetch(webhookUrl, {
         method: 'POST',
   headers: {
 'Content-Type': 'application/json',
            },
     body: JSON.stringify(payload)
        });

      if (response.ok) {
 alert('Message sent successfully!');
        } else {
       const error = await response.text();
        alert('Failed to send message: ' + error);
        }
} catch (error) {
 alert('Error sending message: ' + error.message);
    }
}

// Token validator functionality with detailed analysis
function validateToken() {
    const token = document.getElementById('token-input').value;
    
    if (!token) {
        alert('Please enter a token');
        return;
    }

    try {
    const tokenParts = token.split('.');
  if (tokenParts.length !== 3) {
    alert('Invalid token format - Discord tokens should have 3 parts');
    return;
        }

      const payload = JSON.parse(atob(tokenParts[1]));
      const details = {
  id: payload.id || 'Unknown',
         type: getTokenType(payload),
        createdAt: payload.iat ? new Date(payload.iat * 1000).toLocaleString() : 'Unknown',
 expiresAt: payload.exp ? new Date(payload.exp * 1000).toLocaleString() : 'Never'
        };

        document.getElementById('token-analysis').innerHTML = `
   <h3>Token Analysis:</h3>
          <p>Token Type: ${details.type}</p>
  <p>Application ID: ${details.id}</p>
          <p>Created: ${details.createdAt}</p>
            <p>Expires: ${details.expiresAt}</p>
   `;
    } catch (e) {
 alert('Invalid token: Could not decode payload');
    }
}

function getTokenType(payload) {
    if (payload.bot) return 'Bot Token';
    if (payload.webhook) return 'Webhook Token';
    return 'User Token';
}

// Enhanced permissions calculator with role management
const DISCORD_PERMISSIONS = {
    'Administrator': 0x8,
    'Manage Server': 0x20,
    'Manage Roles': 0x10000000,
    'Manage Channels': 0x10,
    'Kick Members': 0x2,
    'Ban Members': 0x4,
    'Create Instant Invite': 0x1,
    'Change Nickname': 0x4000000,
    'Manage Nicknames': 0x8000000,
    'Manage Emojis': 0x40000000,
    'Manage Webhooks': 0x20000000,
    'View Channels': 0x400,
    'Send Messages': 0x800,
    'Send TTS Messages': 0x1000,
    'Manage Messages': 0x2000,
    'Embed Links': 0x4000,
    'Attach Files': 0x8000,
    'Read Message History': 0x10000,
    'Mention Everyone': 0x20000,
    'Use External Emojis': 0x40000,
    'Add Reactions': 0x40,
    'View Audit Log': 0x80,
    'Priority Speaker': 0x100,
    'Stream': 0x200,
    'View Guild Insights': 0x80000,
    'Connect': 0x100000,
    'Speak': 0x200000,
    'Mute Members': 0x400000,
    'Deafen Members': 0x800000,
    'Move Members': 0x1000000,
    'Use VAD': 0x2000000
};

// Initialize permissions calculator with preset templates
window.addEventListener('DOMContentLoaded', () => {
    const permissionsList = document.querySelector('.permissions-list');
    
    // Add permission checkboxes
    Object.entries(DISCORD_PERMISSIONS).forEach(([perm, value]) => {
    const div = document.createElement('div');
        div.innerHTML = `
            <label class="permission-label">
     <input type="checkbox" value="${value}" onchange="calculatePermissions()">
        ${perm}
       </label>
        `;
        permissionsList.appendChild(div);
    });

// Add preset templates
    const templates = {
        'Admin': ['Administrator'],
 'Moderator': ['Manage Messages', 'Kick Members', 'Ban Members', 'View Audit Log'],
        'Helper': ['View Channels', 'Send Messages', 'Read Message History', 'Add Reactions']
 };

    const templateSelect = document.getElementById('permission-template');
    Object.keys(templates).forEach(template => {
   const option = document.createElement('option');
        option.value = template;
        option.textContent = template;
        templateSelect.appendChild(option);
    });

    // Template change handler
    templateSelect.addEventListener('change', () => {
        const selected = templates[templateSelect.value] || [];
        document.querySelectorAll('.permissions-list input[type="checkbox"]').forEach(checkbox => {
     checkbox.checked = selected.includes(checkbox.parentElement.textContent.trim());
     });
        calculatePermissions();
  });
});

function calculatePermissions() {
    const checkboxes = document.querySelectorAll('.permissions-list input[type="checkbox"]');
    let total = 0n;
    
    checkboxes.forEach(checkbox => {
    if (checkbox.checked) {
         total += BigInt(checkbox.value);
        }
    });
    
    const result = document.getElementById('permission-integer');
    result.textContent = total.toString();
    
    // Add copy button functionality
    const copyBtn = document.createElement('button');
    copyBtn.textContent = 'Copy';
    copyBtn.onclick = () => {
        navigator.clipboard.writeText(total.toString());
   alert('Permission integer copied to clipboard!');
    };
    
    if (!result.nextElementSibling || result.nextElementSibling.tagName !== 'BUTTON') {
   result.parentNode.appendChild(copyBtn);
    }
}

// JSON Formatter utility
function formatJSON() {
    const input = document.getElementById('json-input').value;
    const output = document.getElementById('json-output');
    
try {
      const parsed = JSON.parse(input);
        output.value = JSON.stringify(parsed, null, 2);
     output.classList.remove('error');
    } catch (e) {
        output.value = 'Invalid JSON: ' + e.message;
        output.classList.add('error');
    }
}

// Initialize the first section as visible
document.addEventListener('DOMContentLoaded', () => {
    showSection('bot-testing');
});

// Theme switcher functionality
let currentTheme = 'dark';

function toggleTheme() {
    const root = document.documentElement;
    if (currentTheme === 'dark') {
        root.style.setProperty('--background', '#ffffff');
        root.style.setProperty('--secondary-bg', '#f2f3f5');
        root.style.setProperty('--tertiary-bg', '#e3e5e8');
  root.style.setProperty('--text', '#2e3338');
        root.style.setProperty('--text-muted', '#747f8d');
     currentTheme = 'light';
        document.querySelector('.theme-switcher i').classList.replace('fa-moon', 'fa-sun');
    } else {
        root.style.setProperty('--background', '#36393f');
        root.style.setProperty('--secondary-bg', '#2f3136');
        root.style.setProperty('--tertiary-bg', '#202225');
        root.style.setProperty('--text', '#dcddde');
    root.style.setProperty('--text-muted', '#72767d');
        currentTheme = 'dark';
        document.querySelector('.theme-switcher i').classList.replace('fa-sun', 'fa-moon');
    }
}

// Enhanced notification system
function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.innerHTML = message;
    document.body.appendChild(notification);

    setTimeout(() => {
        notification.classList.add('show');
    }, 100);

    setTimeout(() => {
        notification.classList.remove('show');
      setTimeout(() => {
         notification.remove();
  }, 300);
    }, 3000);
}

// Command Builder functionality
let commandOptions = [];

function addCommandOption() {
    const option = {
        type: 'STRING',
  name: '',
      description: '',
        required: false
    };
    commandOptions.push(option);
    updateCommandPreview();
    renderCommandOptions();
}

function updateCommandPreview() {
    const name = document.getElementById('command-name').value;
    const description = document.getElementById('command-description').value;
    
    const commandCode = `
new SlashCommandBuilder()
    .setName('${name}')
  .setDescription('${description}')
${commandOptions.map(opt => `    .addStringOption(option =>
 option
            .setName('${opt.name}')
.setDescription('${opt.description}')
         .setRequired(${opt.required})
    )`).join('\n')}
    .toJSON();
`.trim();

    document.getElementById('command-code').textContent = commandCode;
}

function renderCommandOptions() {
    const container = document.getElementById('command-options');
    const optionsHtml = commandOptions.map((opt, index) => `
 <div class="command-option">
          <input type="text" placeholder="Option name" 
       value="${opt.name}" 
      onchange="updateOptionName(${index}, this.value)">
            <input type="text" placeholder="Option description" 
 value="${opt.description}" 
     onchange="updateOptionDescription(${index}, this.value)">
      <label>
       <input type="checkbox" 
     ${opt.required ? 'checked' : ''} 
     onchange="updateOptionRequired(${index}, this.checked)">
     Required
     </label>
     <button onclick="removeOption(${index})" class="danger-button">
<i class="fas fa-trash"></i>
      </button>
        </div>
    `).join('');
    
    container.innerHTML = optionsHtml;
}

// API Tester functionality
async function testAPI() {
    const endpoint = document.getElementById('api-endpoint').value;
    const method = document.getElementById('api-method').value;
    const body = document.getElementById('api-body').value;
    
    try {
        const response = await fetch(`https://discord.com/api/v10${endpoint}`, {
       method,
            headers: {
          'Authorization': `Bot ${document.getElementById('bot-token').value}`,
      'Content-Type': 'application/json'
  },
       body: method !== 'GET' ? body : undefined
 });
   
        const data = await response.json();
        document.getElementById('api-response').innerHTML = `
            <div class="response-header">
    <span>Status: ${response.status}</span>
    <button onclick="copyResponse()" class="secondary-button">
         <i class="fas fa-copy"></i> Copy
      </button>
         </div>
          <pre>${JSON.stringify(data, null, 2)}</pre>
        `;
    } catch (error) {
        showNotification(error.message, 'error');
    }
}

// Enhanced Webhook Manager
function updateWebhookPreview() {
    const preview = document.getElementById('webhook-preview');
    const message = document.getElementById('webhook-message').value;
    const embedTitle = document.getElementById('embed-title').value;
    const embedDescription = document.getElementById('embed-description').value;
    const embedColor = document.getElementById('embed-color').value;
    
    preview.innerHTML = `
        <div class="webhook-message-preview">
    <div class="message-content">${message}</div>
      ${embedTitle || embedDescription ? `
            <div class="embed-preview" style="border-left: 4px solid ${embedColor}">
  ${embedTitle ? `<div class="embed-title">${embedTitle}</div>` : ''}
       ${embedDescription ? `<div class="embed-description">${embedDescription}</div>` : ''}
  </div>
       ` : ''}
  </div>
    `;
}

// Server Templates
const serverTemplates = {
    gaming: {
      name: 'Gaming Community',
        channels: [
            { name: '📢announcements', type: 'GUILD_TEXT' },
         { name: '🎮game-discussion', type: 'GUILD_TEXT' },
      { name: '🔧bot-commands', type: 'GUILD_TEXT' },
            { name: '🎙️Gaming Voice', type: 'GUILD_VOICE' }
        ],
        roles: [
       { name: 'Admin', color: '#FF0000', permissions: ['ADMINISTRATOR'] },
  { name: 'Moderator', color: '#00FF00', permissions: ['MANAGE_MESSAGES', 'KICK_MEMBERS'] },
      { name: 'Member', color: '#0000FF', permissions: ['READ_MESSAGES', 'SEND_MESSAGES'] }
        ]
    },
    // Add more templates...
};

function useTemplate(templateName) {
    const template = serverTemplates[templateName];
  if (!template) {
   showNotification('Template not found', 'error');
        return;
    }
    
    // Generate template code
    const code = generateTemplateCode(template);
    navigator.clipboard.writeText(code);
    showNotification('Template code copied to clipboard!', 'success');
}

// Server Cloner functionality
async function cloneServer() {
    const sourceToken = document.getElementById('source-token').value;
  const sourceServerId = document.getElementById('source-server-id').value;
    const targetToken = document.getElementById('target-token').value;

    if (!sourceToken || !sourceServerId || !targetToken) {
 showNotification('Please fill in all required fields', 'error');
   return;
    }

    try {
      // First, get source server details
  const sourceGuild = await fetchGuildData(sourceToken, sourceServerId);
if (!sourceGuild) {
      showNotification('Could not fetch source server details', 'error');
       return;
  }

      showNotification('Starting server clone process...', 'info');
        
        // Create new guild
    const newGuild = await createGuild(targetToken, {
         name: sourceGuild.name + ' (Clone)',
            icon: sourceGuild.icon
        });

        if (!newGuild) {
      showNotification('Failed to create new server', 'error');
            return;
        }

        // Start cloning process
  await cloneGuildContent(sourceToken, targetToken, sourceServerId, newGuild.id);
        
        showNotification('Server cloned successfully! Server ID: ' + newGuild.id, 'success');
        
    } catch (error) {
showNotification('Error during cloning: ' + error.message, 'error');
    }
}

async function fetchGuildData(token, guildId) {
    try {
     const response = await fetch(`https://discord.com/api/v10/guilds/${guildId}`, {
            headers: {
         'Authorization': `Bot ${token}`,
      'Content-Type': 'application/json'
            }
        });
        
        if (!response.ok) throw new Error('Failed to fetch guild data');
 return await response.json();
    } catch (error) {
   console.error('Error fetching guild:', error);
        return null;
    }
}

async function createGuild(token, data) {
    try {
     const response = await fetch('https://discord.com/api/v10/guilds', {
        method: 'POST',
            headers: {
        'Authorization': `Bot ${token}`,
    'Content-Type': 'application/json'
            },
          body: JSON.stringify(data)
        });
        
        if (!response.ok) throw new Error('Failed to create guild');
        return await response.json();
} catch (error) {
        console.error('Error creating guild:', error);
        return null;
 }
}

async function cloneGuildContent(sourceToken, targetToken, sourceGuildId, targetGuildId) {
    try {
   // Clone roles
        const roles = await fetchGuildRoles(sourceToken, sourceGuildId);
        for (const role of roles.reverse()) {
            if (role.managed || role.name === '@everyone') continue;
            await createRole(targetToken, targetGuildId, {
      name: role.name,
 color: role.color,
        hoist: role.hoist,
          permissions: role.permissions,
                mentionable: role.mentionable
    });
        }

        // Clone channels
        const channels = await fetchGuildChannels(sourceToken, sourceGuildId);
   const categoryChannels = channels.filter(c => c.type === 4);
    const textChannels = channels.filter(c => c.type === 0);
        const voiceChannels = channels.filter(c => c.type === 2);

        // Create categories first
        for (const category of categoryChannels) {
     await createChannel(targetToken, targetGuildId, {
       name: category.name,
         type: 4,
             position: category.position,
permission_overwrites: category.permission_overwrites
            });
        }

        // Create text and voice channels
        for (const channel of [...textChannels, ...voiceChannels]) {
    await createChannel(targetToken, targetGuildId, {
       name: channel.name,
 type: channel.type,
 position: channel.position,
         parent_id: channel.parent_id,
  permission_overwrites: channel.permission_overwrites,
     topic: channel.topic,
                nsfw: channel.nsfw,
      rate_limit_per_user: channel.rate_limit_per_user,
       user_limit: channel.user_limit
   });
        }

      // Clone emojis
        const emojis = await fetchGuildEmojis(sourceToken, sourceGuildId);
        for (const emoji of emojis) {
       await createEmoji(targetToken, targetGuildId, {
       name: emoji.name,
     image: await getEmojiImage(emoji.id)
     });
   }

    } catch (error) {
        console.error('Error cloning guild content:', error);
        throw error;
    }
}

async function fetchGuildRoles(token, guildId) {
    const response = await fetch(`https://discord.com/api/v10/guilds/${guildId}/roles`, {
        headers: {
  'Authorization': `Bot ${token}`
        }
    });
    return await response.json();
}

async function fetchGuildChannels(token, guildId) {
    const response = await fetch(`https://discord.com/api/v10/guilds/${guildId}/channels`, {
        headers: {
            'Authorization': `Bot ${token}`
        }
    });
    return await response.json();
}

async function fetchGuildEmojis(token, guildId) {
    const response = await fetch(`https://discord.com/api/v10/guilds/${guildId}/emojis`, {
        headers: {
'Authorization': `Bot ${token}`
   }
    });
  return await response.json();
}

async function createRole(token, guildId, data) {
await fetch(`https://discord.com/api/v10/guilds/${guildId}/roles`, {
        method: 'POST',
        headers: {
            'Authorization': `Bot ${token}`,
    'Content-Type': 'application/json'
        },
        body: JSON.stringify(data)
    });
}

async function createChannel(token, guildId, data) {
    await fetch(`https://discord.com/api/v10/guilds/${guildId}/channels`, {
      method: 'POST',
        headers: {
            'Authorization': `Bot ${token}`,
         'Content-Type': 'application/json'
        },
        body: JSON.stringify(data)
    });
}

async function createEmoji(token, guildId, data) {
    await fetch(`https://discord.com/api/v10/guilds/${guildId}/emojis`, {
        method: 'POST',
        headers: {
      'Authorization': `Bot ${token}`,
            'Content-Type': 'application/json'
        },
     body: JSON.stringify(data)
    });
}

async function getEmojiImage(emojiId) {
    const response = await fetch(`https://cdn.discordapp.com/emojis/${emojiId}.png`);
    const blob = await response.blob();
    return new Promise((resolve) => {
        const reader = new FileReader();
     reader.onloadend = () => resolve(reader.result.split(',')[1]);
      reader.readAsDataURL(blob);
 });
}

// Event listeners
document.addEventListener('DOMContentLoaded', () => {
    // Initialize tooltips
    document.querySelectorAll('[data-tooltip]').forEach(element => {
     element.addEventListener('mouseenter', e => {
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
    tooltip.textContent = e.target.dataset.tooltip;
       document.body.appendChild(tooltip);
       
            const rect = e.target.getBoundingClientRect();
            tooltip.style.left = rect.left + (rect.width / 2) - (tooltip.offsetWidth / 2) + 'px';
    tooltip.style.top = rect.top - tooltip.offsetHeight - 10 + 'px';
  });
        
        element.addEventListener('mouseleave', () => {
            document.querySelector('.tooltip')?.remove();
        });
    });
 
    // Add input event listeners for webhook preview
    ['webhook-message', 'embed-title', 'embed-description', 'embed-color'].forEach(id => {
     document.getElementById(id)?.addEventListener('input', updateWebhookPreview);
    });
});